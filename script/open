#!/data/data/com.termux/files/usr/bin/bash
# Advanced Smart File Manager with Fixed Move Functionality

handle_file() {
    local file="$1"
    while true; do
        echo
        echo "ğŸ“„ File selected: $(basename "$file")"
        echo "What would you like to do with the file?"
        echo "1) Open using external tool (termux-open)"
        echo "2) Edit using nano"
        echo "3) Delete file"
        echo "4) Back to browser"
        read -p "Enter choice [1-4]: " action

        case "$action" in
            1)
                termux-open "$file"
                ;;
            2)
                nano "$file"
                ;;
            3)
                if rm -i "$file"; then
                    echo "âœ… File deleted"
                    return 1
                fi
                ;;
            4)
                return 1
                ;;
            *)
                echo "âŒ Invalid option. Try again."
                ;;
        esac
    done
}

get_abs_path() {
    local target="$1"
    if [ -d "$target" ]; then
        cd -- "$target" && pwd
    elif [ -f "$target" ]; then
        local dir=$(dirname -- "$target")
        local base=$(basename -- "$target")
        echo "$(cd -- "$dir" && pwd)/$base"
    else
        echo "Error: '$target' does not exist" >&2
        return 1
    fi
}

create_files() {
    read -p "Enter filenames (separated by |): " filelist
    IFS='|' read -ra files <<< "$filelist"
    for file in "${files[@]}"; do
        touch "$path/$file"
        echo "âœ… Created file: $file"
    done
}

create_dirs() {
    read -p "Enter folder names (separated by |): " dirlist
    IFS='|' read -ra dirs <<< "$dirlist"
    for dir in "${dirs[@]}"; do
        mkdir -p "$path/$dir"
        echo "âœ… Created folder: $dir"
    done
}

move_items() {
    # Select items to move
    echo "Select items to move (enter numbers separated by |)"
    read -p "Item numbers: " itemlist
    IFS='|' read -ra indices <<< "$itemlist"
    
    # Collect selected items
    selected_items=()
    for index in "${indices[@]}"; do
        if [[ $index =~ ^[0-9]+$ ]] && [ $index -ge 1 ] && [ $index -le ${#items[@]} ]; then
            selected_items+=("${items[$((index-1))]}")
        else
            echo "âŒ Skipping invalid index: $index"
        fi
    done

    if [ ${#selected_items[@]} -eq 0 ]; then
        echo "âŒ No valid items selected"
        return
    fi

    # Show selected items
    echo
    echo "ğŸ“¦ Selected items:"
    for item in "${selected_items[@]}"; do
        echo "- $(basename "$item")"
    done
    
    # Save current path for destination selection
    original_path="$path"
    path="$HOME"
    move_mode=true
    echo
    echo "ğŸŒ Navigate to destination folder (select folder or use commands)"
    echo "Press 'c' at destination to confirm move"
    echo "Press 'b' to cancel move operation"
}

# Initialize global variables
path=$(pwd)
move_mode=false
selected_items=()
original_path=""

# Handle command-line arguments
if [ $# -eq 1 ]; then
    target="$1"
    
    if [ -d "$target" ]; then
        path=$(get_abs_path "$target")
    elif [ -f "$target" ]; then
        selected=$(get_abs_path "$target")
        handle_file "$selected"
        exit $?
    else
        echo "Error: '$target' not found" >&2
        exit 1
    fi
fi

shopt -s nullglob
while true; do
    echo
    if $move_mode; then
        echo "ğŸšš MOVE MODE: Select destination folder"
    else
        echo "ğŸ“‚ Location: $path"
    fi
    
    items=("$path"/*)
    
    if [ ${#items[@]} -eq 0 ]; then
        echo "ğŸ›‘ This directory is empty"
    else
        idx=1
        for item in "${items[@]}"; do
            if [ -d "$item" ]; then
                icon="ğŸ“"
            else
                icon="ğŸ“„"
            fi
            printf "%2d) %s %s\n" "$idx" "$icon" "$(basename "$item")"
            idx=$((idx+1))
        done
    fi

    echo
    if $move_mode; then
        echo "c) Confirm move to this folder   b) Cancel move"
    else
        echo "n) New folder    f) New file    u) Up directory"
        echo "c) CD to here    m) Move items  q) Quit"
    fi
    
    read -p "Select item number or command: " choice

    # Handle move mode commands
    if $move_mode; then
        case "$choice" in
            c|C)
                # Perform the move operation
                for item in "${selected_items[@]}"; do
                    mv -v "$item" "$path/"
                done
                echo "âœ… Items moved successfully"
                
                # Return to original location
                move_mode=false
                path="$original_path"
                selected_items=()
                continue
                ;;
            b|B)
                echo "ğŸš« Move operation cancelled"
                move_mode=false
                path="$original_path"
                selected_items=()
                continue
                ;;
        esac
    fi

    # Handle normal mode commands
    case "$choice" in
        q|Q)
            exit 0
            ;;
        u|U)
            [ "$path" != "/" ] && path=$(dirname "$path")
            continue
            ;;
        n|N)
            create_dirs
            continue
            ;;
        f|F)
            create_files
            continue
            ;;
        c|C)
            cd '$path'
            continue
            ;;
        m|M)
            if [ ${#items[@]} -eq 0 ]; then
                echo "âŒ No items to move"
            else
                move_items
            fi
            continue
            ;;
    esac

    # Handle numeric selection
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt "${#items[@]}" ]; then
        echo "âš ï¸  Invalid selection" >&2
        continue
    fi

    selected="${items[$((choice-1))]}"

    if [ -d "$selected" ]; then
        path="$selected"
    elif [ -f "$selected" ]; then
        if $move_mode; then
            echo "âš ï¸  Please select a folder for destination"
        else
            handle_file "$selected"
        fi
    else
        echo "â“ Unsupported item type" >&2
    fi
done
